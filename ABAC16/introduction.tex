\section{Introduction}

Access control has been a major component in enforcing security and privacy requirements of information and resources with respect to unauthorized access. While many access control models have been proposed only three, viz., DAC, MAC and RBAC, have received meaningful practical deployment. DAC (Discretionary Access Control) \cite{sandhu1994access} allows resource owners to retain control on their resources by specifying who can or cannot access certain resources. To address inherent limitations of DAC such as trojan horses, MAC (Mandatory Access Control) \cite{sandhu1994access}  has been proposed which mandates access to resources by pre-specified system policies. While both of these two models are based on fixed and predetermined policies, RBAC (Role Based Access Control) \cite{rbac} is a policy neutral, flexible and administrative friendly model.  Notably RBAC is capable of enforcing both DAC and MAC.  MAC is also commonly referred to as LBAC (Lattice-Based Access Control).

Attribute Based Access Control (ABAC) has gained considerable attention from businesses, academia and standard bodies (NIST \cite{nist-abac-draft} and NCCOE \cite{nccoe-abac-draft}) in recent years. ABAC uses attributes on users, objects and possibly other entities (e.g. context/environment) and specifies rules using these attributes to assert who can have which access permissions (e.g. read/write) on which objects.  Although ABAC concepts have been around for over two decades there remains a lack of well-accepted ABAC models.  Recently there has been a resurgence of interest in ABAC due to continued dissatisfaction with the three traditional models, particularly the limitations of RBAC.

%On the other hand, researchers and practitioners have long recognized essence of  attributes (user attributes, object attributes and context/environment attributes) in authentication and/or authorization decisions. For example, X.500 and X.509 \cite{xfiveonine}, LDAP \cite{ldap} or XACML \cite{xacml} are available for a long time which use attributes for either authentication or authorization decision. Some advantages of attributes in the authorization decision include following.

%Besides these models, researchers and practitioners have long recognized essence of  attributes (user attributes, object attributes and context/environment attributes) in authentication and/or authorization decisions. For example, X.500 and X.509 \cite{xfiveonine}, LDAP \cite{ldap} or XACML \cite{xacml} are familiar practitioner standard in this line available for a long time. The motivation of using attributes along with identities is long-standing. Attributes over identities are convenient in the following ways.

%\begin{itemize}
	%\item \emph{Hard to know user's real identity in a Open Environment: } In order to use identities, user's real identity has to be known beforehand. Often time, it is not possible to know the real identity of a user, specially when users come from a open environment like the Internet.
	
	%\item \emph{Hard to manage access control decision in large scale using Identity:} Using identities to specify access control decision, soon become infeasible when there are large number of users or objects to manage. On the other hand, as many users or objects can be specified using smaller set of attributes, they  are more preferable  in large distributed environment.
	
	%\item \emph{Anonymity or partial Identity:} Some times it is not required or even desirable to provide access control without knowing the real identity of a user. For example, in case of a digital library it may be enough to know some of the user attributes like membership or affiliation. On the other hand, for eligibility requirement of buying an alcoholic beverage, the age attribute may suffice without revealing the real identity.
	
	%\item \emph{Richer model for business function or logic in the authorization process:} Role, role hierarchy, role-based constraint easily capture some of the business function or logic of an organization related to role or job position in the organization. But in order to express business requirements in a more coherent way, it requires support for additional attributes.
	
%\end{itemize}



%Motivated by these requirements, various models have been proposed that accommodate attributes with traditional RBAC model \cite{rbac-with-attribute1, kuhn2010adding}. Another line of work is toward defining  a standalone model for Attribute Based Access Control (ABAC).

To demonstrate expressive power and flexibility, several ABAC models including  \cite{abacAlpha,hgabac,abac-for-web-service} have been proposed in past few years. These models adopt the conventional approach of designing attribute based rules/policies as logical formulas. Using logical formulas to grant or deny access is convenient because of the following reasons.

\begin{itemize}
	\item \emph{Simple and easy:} Creating a new rule for granting access is simple. It does not involve upfront cost like engineering roles in case of RBAC.
	
	\item \emph{Flexible:} Rules are easy to succinctly specify even complex policies. There is no limit on how many attributes can be used in a rule or how complex the language be to specify the rule. Given a required set of attributes, and a computational language, ABAC policy is only limited to what the language can express \cite{nist-abac-draft}.
\end{itemize}

Interestingly, designing a rich computational language to define attribute-based rules makes policy update or policy review an NP-complete or even undecidable problem. For example, authorization policies in many existing ABAC models including \cite{abacAlpha, hgabac, abac-for-web-service} are expressed  in propositional logic. Reviewing policy in these models (which may simply ask, for a given policy  which (attribute, value) pairs evaluate the policy to be true) is similar to the satisfiability problem in propositional logic which is NP-complete. Likewise review for policies specified in first-order logic is undecidable.

Another method for specifying attribute-based policies is by enumeration. Policy Machine \cite{policy-machine} and \twoSortedRBAC{} \cite{two-sorted-rbac} fall into this category. Enumerated policies  can also be very expressive. Ferraiolo et al \cite{policy-machine} show configuration of LBAC, DAC and RBAC in Policy Machine using enumerated policies.  Moreover, updating or reviewing an enumerated policy is inherently simple (polynomial time) because of its simple structure.  It should be noted that the size of an enumerated policy may be exponential relative to a succinct formula which expresses the same policy.  Thus there is a trade-off between these two methods for specifying policies.

In this paper, we present an ABAC model named Label-Based Access Control (LaBAC). In LaBAC, users are assigned a single label named $\uLabel$ and objects are assigned a single label named $\oLabel$. For a particular action, a policy in LaBAC is an enumeration using $\uLabel$ and $\oLabel$ values.

Labels ($\uLabel$ and $\oLabel$) in LaBAC are special types of attributes. While semantics of attributes in general are open-ended, labels have very specific semantics. For example, in general attributes can be set valued (e.g. roles) or atomic valued (e.g. age). Values of an attribute can be assigned by administrators (e.g. roles), derived from other attributes (e.g. membership type), self asserted (e.g. date of birth),  system specified (e.g. time) and so on. Moreover, values can be ordered or unordered.  On the other  hand, labels are specifically defined to be set valued, values are partially ordered and are only assigned by administrators. Intentionally, we use abstract names for labels---$\uLabel$ and $\oLabel$.  In an actual instance of LaBAC, labels can be given more appropriate names. For example, roles or clearance for $\uLabel$ and classification or sensitivity for $\oLabel$.

%In this paper, we represent LaBAC as a family of models---starting from the basic model, \clabac{} to the most advanced model, \labacOneOneOne{}.  In \hlabac{}, we add label hierarchies to \clabac{} while in \consLabac{} we add additional machinery to express constraints using labels. Finally, \labacOneOneOne{} combines all three models.

We analyze the expressive power of LaBAC with respect to other enumerative models. We also show that LaBAC can be viewed as a simple instance of Policy Machine (PM).  While, PM is more general and complex by covering other interesting aspects of access control, LaBAC is more scoped regarding development and progress towards ABAC models. On the other hand, we show equivalence of LaBAC and \twoSortedRBAC{} with respect to theoretical expressive power. Finally, we show flexibility of LaBAC by configuring traditional models (LBAC \cite{lbac} and RBAC\cite{rbac}) in it.

Rest of the paper is organized as follows. In Section \ref{sec:background}, we briefly discuss logic-based policy and enumerated policy along with a review of related literature. Section \ref{sec:model} presents a family of LaBAC models. We show the equivalence of LaBAC and \twoSortedRBAC{} in Section \ref{sec:equivalence}. Section \ref{sec:configuration} presents configuration of tradition RBAC and LBAC policy in LaBAC. We express LaBAC as a simple instance of Policy Machine in Section \ref{sec:pm}. Finally, Section \ref{sec:conclusion} concludes the paper.

%   which adopts the enumerated style for expressing authorization policies. LaBAC can  be viewed as a simple instance of Policy Machine (PM). LaBAC uses one user attribute ($\uLabel$) and one object attribute ($\oLabel$) and a authorization policy in LaBAC for an action is an enumeration using these two attributes. 